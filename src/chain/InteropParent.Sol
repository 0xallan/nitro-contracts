// Copyright 2022-2024, Offchain Labs, Inc.
// For license information, see https://github.com/nitro/blob/master/LICENSE
// SPDX-License-Identifier: BUSL-1.1

pragma solidity ^0.8.0;

import "../bridge/IInbox.sol";
import "../precompiles/ArbSys.sol";

contract InteropParent {
    ArbSys internal constant ARB_SYS = ArbSys(address(0x64));

    struct Bid {
        address counter;
        bytes32 meta;
    }

    struct Agreement {
        address origin;
        int64 chosen;
        Bid[] bids;
    }

    Agreement[] public agreements;

    function create() public returns (uint256) {
        Bid[] memory emptybids;
        uint256 nextId;
        nextId = agreements.length;
        agreements.push(Agreement(msg.sender, -1, emptybids));
        return nextId;
    }

    function bid(uint64 agreement, address counter, bytes32 meta, uint256 cond_blocknum, bytes32 cond_hash) public returns (uint256) {
        require(agreements.length > agreement, "illegal agreement");
        require(agreements[agreement].chosen == -1, "closed agreement");
        if (cond_blocknum > 0) {
            require(ARB_SYS.arbBlockHash(cond_blocknum) == cond_hash, "condition not met");
        }
        uint256 nextBid;
        nextBid = agreements[agreement].bids.length;
        agreements[agreement].bids.push(Bid(counter, meta));
        return nextBid;
    }

    function agree(uint64 agreement, int64 ibid, bytes32 meta, uint256 cond_blocknum, bytes32 cond_hash) public {
        require(agreements.length > agreement, "illegal agreement");
        require(agreements[agreement].chosen == -1, "closed agreement");
        require(agreements[agreement].origin == msg.sender, "not originator");
        require(ibid >= 0, "illegal bid");
        uint64 ubid;
        ubid = uint64(ibid);
        require(agreements[agreement].bids.length > ubid, "illegal bid");
        require(agreements[agreement].bids[ubid].meta == meta, "wrong bid meta");

        if (cond_blocknum > 0) {
            require(ARB_SYS.arbBlockHash(cond_blocknum) == cond_hash, "condition not met");
        }
        agreements[agreement].chosen = ibid;
    }

    function send_result(uint64 agreement, IInbox dest_chain, address dest_contract, uint256 gasLimit,
        uint256 maxFeePerGas, address to) {
        require(agreements.length > agreement, "illegal agreement");
        require(agreements[agreement].chosen > 0, "open agreement");
        uint64 ubid;
        ubid = uint64(agreements[agreement].chosen);

        dest_chain.sendL1FundedContractTransaction(gasLimit, maxFeePerGas, dest_contract, msg.value, abi.encodePacked(
            bytes4(uint32(0x11223344)), // TODO: destfunc
            abi.encode(agreements[agreement].bids[ubid].counter, agreements[agreement].bids[ubid].meta) 
        ));        
    }
}
