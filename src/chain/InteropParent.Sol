// Copyright 2022-2024, Offchain Labs, Inc.
// For license information, see https://github.com/nitro/blob/master/LICENSE
// SPDX-License-Identifier: BUSL-1.1

pragma solidity ^0.8.0;

import "./IInteropParent.sol";
import "./IInteropChild.sol";
import "../bridge/IInbox.sol";
import "../precompiles/ArbSys.sol";

contract InteropParent is IInteropParent {
    ArbSys internal constant ARB_SYS = ArbSys(address(0x64));

    Agreement[] public agreements;
    mapping(uint256 => Bid[]) public aBids;

    function create() public returns (uint256) {
        uint256 agreementId = agreements.length;
        agreements.push(Agreement(msg.sender, -1));
        return agreementId;
    }

    /// @return index of the bid in allBids
    function bid(
        uint64 agreement,
        address counter,
        bytes32 meta,
        uint256 condBlocknum,
        bytes32 condHash
    ) public returns (uint256) {
        require(agreements.length > agreement, "illegal agreement");
        require(agreements[agreement].chosen == -1, "closed agreement");
        if (condBlocknum > 0) {
            require(ARB_SYS.arbBlockHash(condBlocknum) == condHash, "condition not met");
        }

        uint256 ubidId;
        ubidId = aBids[agreement].length;
        aBids[agreement].push(Bid(counter, meta));
        return ubidId;
    }

    function agree(
        uint64 agreement,
        int64 ibid,
        bytes32 meta,
        uint256 condBlocknum,
        bytes32 condHash
    ) public {
        require(agreements.length > agreement, "illegal agreement");
        require(agreements[agreement].chosen == -1, "closed agreement");
        require(agreements[agreement].origin == msg.sender, "not originator");
        require(ibid >= 0, "illegal bid");
        uint64 ubid;
        ubid = uint64(ibid);
        require(aBids[agreement].length > ubid, "illegal bid");
        require(aBids[agreement][ubid].meta == meta, "wrong bid meta");

        if (condBlocknum > 0) {
            require(ARB_SYS.arbBlockHash(condBlocknum) == condHash, "condition not met");
        }
        agreements[agreement].chosen = ibid;
    }

    function sendResult(
        uint64 agreement,
        address destChain,
        address destContract,
        uint256 gasLimit,
        uint256 maxFeePerGas,
        uint256 maxSubmissionCost
    ) external payable {
        require(agreements.length > agreement, "illegal agreement");
        require(agreements[agreement].chosen > 0, "open agreement");
        uint64 ubid = uint64(agreements[agreement].chosen);
        Bid memory _bid = aBids[agreement][ubid]; // workaround stack too deep

        uint256 l2CallValue = msg.value - maxSubmissionCost - maxFeePerGas * gasLimit;
        IInbox(destChain).createRetryableTicket{value: msg.value}({
            to: destContract,
            l2CallValue: l2CallValue,
            maxSubmissionCost: 0,
            excessFeeRefundAddress: address(0),
            callValueRefundAddress: address(0),
            gasLimit: gasLimit,
            maxFeePerGas: maxFeePerGas,
            data: abi.encodeCall(
                IInteropChild.receiveResult, // TODO: destfunc
                (_bid.counter, _bid.meta)
            )
        });
    }
}
