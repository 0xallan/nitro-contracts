// Copyright 2022-2024, Offchain Labs, Inc.
// For license information, see https://github.com/nitro/blob/master/LICENSE
// SPDX-License-Identifier: BUSL-1.1

pragma solidity ^0.8.0;

import "./IInteropParent.sol";
import "./IInteropChild.sol";
import "../bridge/IInbox.sol";
import "../precompiles/ArbSys.sol";

contract InteropParent is IInteropParent {
    ArbSys internal constant ARB_SYS = ArbSys(address(0x64));

    Agreement[] public agreements;
    mapping(uint256 => Bid[]) public aBids;

    function create() public returns (uint256) {
        uint256 agreementId = agreements.length;
        agreements.push(Agreement(msg.sender, type(uint64).max));
        return agreementId;
    }

    function bid(
        uint256 agreementId,
        address counter,
        bytes32 meta,
        uint256 condBlocknum,
        bytes32 condHash
    ) public returns (uint256) {
        require(agreements.length > agreementId, "illegal agreement");
        require(agreements[agreementId].chosen == type(uint64).max, "closed agreement");
        if (condBlocknum > 0) {
            require(ARB_SYS.arbBlockHash(condBlocknum) == condHash, "condition not met");
        }

        uint256 bidId;
        bidId = aBids[agreementId].length;
        aBids[agreementId].push(Bid(counter, meta));
        return bidId;
    }

    function agree(
        uint256 agreementId,
        uint64 bidId,
        bytes32 meta,
        uint256 condBlocknum,
        bytes32 condHash
    ) public {
        require(agreements.length > agreementId, "illegal agreement");
        require(agreements[agreementId].chosen == type(uint64).max, "closed agreement");
        require(agreements[agreementId].origin == msg.sender, "not originator");
        require(aBids[agreementId].length > bidId, "illegal bid");
        require(aBids[agreementId][bidId].meta == meta, "wrong bid meta");

        if (condBlocknum > 0) {
            require(ARB_SYS.arbBlockHash(condBlocknum) == condHash, "condition not met");
        }
        agreements[agreementId].chosen = bidId;
    }

    function sendResult(
        uint256 agreementId,
        address destChain,
        address destContract,
        uint256 gasLimit,
        uint256 maxFeePerGas,
        uint256 maxSubmissionCost,
        uint256 amount
    ) external payable {
        require(agreements.length > agreementId, "illegal agreement");
        require(agreements[agreementId].chosen > 0, "open agreement");
        uint64 ubid = uint64(agreements[agreementId].chosen);
        Bid memory _bid = aBids[agreementId][ubid]; // workaround stack too deep

        require(
            msg.value - maxSubmissionCost - maxFeePerGas * gasLimit == amount,
            "insufficient callvalue"
        );
        IInbox(destChain).createRetryableTicket{value: msg.value}({
            to: destContract,
            l2CallValue: amount,
            maxSubmissionCost: maxSubmissionCost,
            excessFeeRefundAddress: address(0),
            callValueRefundAddress: address(0),
            gasLimit: gasLimit,
            maxFeePerGas: maxFeePerGas,
            data: abi.encodeCall(IInteropChild.receiveResult, (_bid.counter, _bid.meta))
        });
    }
}
